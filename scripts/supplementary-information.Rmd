---
title: "Supplementary Information"
author: "Shawn Cummings and T. Florian Jaeger"
date: "\today"

header-includes:
  - \usepackage{booktabs}
  - \usepackage{siunitx}
  - \usepackage{tabto}
  - \usepackage{soul}
  - \usepackage{xcolor}
  - \usepackage{placeins}
  - \usepackage{lscape}
  - \usepackage{animate}
  - \newcommand{\blandscape}{\begin{landscape}}
  - \newcommand{\elandscape}{\end{landscape}}
  - \makeatletter\renewcommand{\fps@table}{!ht}\makeatother
  - \setstcolor{red}
  - \usepackage{sectsty}
  - \sectionfont{\color{blue}}
  - \subsectionfont{\color{blue}}
  - \subsubsectionfont{\color{darkgray}}
  
geometry: margin=2cm
output:
  pdf_document:
    fig_caption: yes
    fig_width: 7
    keep_tex: yes
    latex_engine: xelatex
    number_sections: yes
    toc: yes
    toc_depth: 4
  fontsize: 10pt
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '4'
---

```{r, include=FALSE}
library(knitr)

opts_chunk$set(dev = 'png',
               comment="", 
               echo=FALSE, warning=TRUE, message=TRUE,
               cache=FALSE, 
               size="small",
               tidy.opts = list(width.cutoff = 200),
               fig.width = 8, fig.height = 4.5, fig.align = "center")


def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  ifelse(options$size != "normalsize", paste0("\n \\", options$size,"\n\n", x, "\n\n \\normalsize"), x)
})

color_block = function(color) {
  function(x, options) sprintf('\\color{%s}\\begin{verbatim}%s\\end{verbatim}\\color{black}',
                               color, x)
}
knitr::knit_hooks$set(error = color_block('red'))
knitr::knit_hooks$set(warning = color_block('orange'))
```

```{r, include=FALSE}
library(tidyverse)
library(magrittr)    # pipes
library(lubridate)   # date conversion, etc.

library(brms)        # Bayesian GL(M)Ms
library(sjPlot)      # tables for Bayesian GL(M)Ms
library(broom)       # extracting information from GL(M)Ms
library(boot)         # easy logit() function

library(linguisticsdown)  #IPA symbols
library(rstan)

# # Setting cmdstanr
# library(curl)
# if (has_internet()) install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
library(cmdstanr)
# install_cmdstan()
```

```{r constants, include=FALSE}
source("constants.R")

# Set priors for all analyses
priors <- 
  c(
    prior(student_t(3,0,2.5), class = b),
    prior(cauchy(0,5), class = sd), 
    prior(lkj(1), class = cor))
```

# TO DO:

## Priority HIGHEST

 * in add_exclusions, there is commented out code at the top of the function. Why is it commented out, and how are we removing participants for technical difficult if not there?

## Priority MEDIUM

 * make sure that data formatting *function* is in *this* repo (raw data should *not* be in this repo)
 * consider adding renaming of variables into formatting function, removing it from early code chunk:
 
 rename(
    Participant.AudioType = Answer.audio_type,
    Participant.AudioStall = Answer.audio_stall,
    Participant.VideoStall = Answer.video_stall,
    Talker.Sex = Answer.sex,
    Talker.PronunciationShift = Answer.ssh2,
    Talker.PronunciationProperties = Answer.pronun,
    Talker.SpeechDescription = Answer.speaker)
 
 * consolidate constants.R and functions.R. It's currently unclear what's in which and why.


# Context statement
This document contains the data preparation, visualization, and analyses reported in the main text. As of 2022, the Human Language Processing Lab, University of Rochester, is committed to producing articles and supplementary information in the form of R Markdown documents whenever possible. This particular project grew out of a yearlong undergraduate research class (BCS 206 "Undergraduate Research in Cognitive Science"). To accommodate differences in familiarity with R programming, and to facilitate project workflow, the authors agreed to write the main text in a common word processing software, and to provide this R Markdown document as supplementary information.

# Experiment 1a-c

## Data import
We import and format the data for Experiments 1a-c, as well as Experiments A and 1 from Liu & Jaeger (2018).

```{r}
load("../data/Experiment-NORM-A-before-exclusions.RData") #named d.test.A
d.Exp1a <- d.test.A %>%
  mutate(
    Experiment = "CISP-1a",
    ParticipantID = paste(Experiment, ParticipantID, sep = "."))
 
load("../data/Experiment-NORM-B-before-exclusions.RData") #named d.test.B
d.Exp1b <- d.test.B %>%
  mutate(
    Experiment = "CISP-1b",
    ParticipantID = paste(Experiment, ParticipantID, sep = "."))

load("../data/Experiment-NORM-C-before-exclusions.RData") #named d.test.C
d.Exp1c <- d.test.C %>%
  mutate(
    Experiment = "CISP-1c",
    ParticipantID = paste(Experiment, ParticipantID, sep = "."))

d.LJ18.test <- 
  read.csv("../data/Liu Jaeger 2018/Liu-Jaeger-2018-test-1-s2.0-S0010027718300118-mmc2.csv") %>%
  # Filter to norming experiment
  filter(
    Condition == 'Filler') %>%
  mutate(
    Experiment = factor('LJ18-NORM'),
    ParticipantID = as.factor(paste0("LJ18.", Subject)), 
    Condition.Test.Audio = Step, 
    Condition.Test.Pen = "audio-only",
    Condition.Test.OriginalLabel = NA,
    Response = factor(case_when(Response == "SH" ~ "ASHI", Response == "S" ~ "ASI")),
    # Blocks were 6 trials per block in LJ18 but 12 in CISP, so we re-calculate
    # blocks for LJ18 to be blocks of 12 trials.
    Block = Trial %/% 12 + 1, 
    Trial = Trial + 1,
    across(
      c(Condition.Test.Pen, Condition.Test.OriginalLabel), 
    factor)) 

d.test <- 
  bind_rows(d.Exp1a, d.Exp1b, d.Exp1c, d.LJ18.test) %>%
  # Potentially move these into the format function
  rename(
    Participant.AudioType = Answer.audio_type,
    Participant.AudioStall = Answer.audio_stall,
    Participant.VideoStall = Answer.video_stall,
    Talker.Sex = Answer.sex,
    Talker.PronunciationShift = Answer.ssh2,
    Talker.PronunciationProperties = Answer.pronun,
    Talker.SpeechDescription = Answer.speaker) %>%
  add_exclusions() %>%
  mutate(
    Condition.Exposure.Pen = NA,
    Condition.Exposure.LexicalLabel = NA,
    Response.ASHI = ifelse(Response == "ASHI", 1, 0)) %>%
  select(
    Experiment, ParticipantID, starts_with("Participant."),
    Condition.Exposure.Pen, Condition.Exposure.LexicalLabel, 
    Condition.Test.Audio, Condition.Test.Pen, Condition.Test.OriginalLabel, Condition.Test.Keybindings,
    Block, Trial, ItemID, 
    Response, Response.ASHI, Response.RT, 
    starts_with("Talker"),
    starts_with("Duration"),
    starts_with("Exclude")) 
```

## Exclusions

```{r}
print(
  d.test %>% 
    distinct(Experiment, ParticipantID, Exclude_Participant.Reason) %>% 
    group_by(Experiment, Exclude_Participant.Reason) %>% 
    tally() %>% 
    group_by(Experiment) %>%
    mutate(Percent = percent(n / sum(n))))

exclusionPlot(d.test %>% filter(Experiment %in% c("CISP-1a", "CISP-1b", "CISP-1c")))

d.test %<>% 
  excludeData()

message(
    "\nData submitted for analysis contains ", 
    nrow(d.test %>% filter(is.na(Response.ASHI))),
    " missing observations (",
    percent(nrow(d.test %>% filter(is.na(Response.ASHI))) / nrow(d.test)),
    "), leaving ",
    nrow(d.test %>% filter(!is.na(Response.ASHI))),
    " observations from ",
    d.test %>% filter(!is.na(Response.ASHI)) %>% pull(ParticipantID) %>% unique() %>% length(),
    " participants from ",
    d.test %>% filter(!is.na(Response.ASHI)) %>% pull(Experiment) %>% unique() %>% length(),
    " experiment(s).")
  
d.test %<>%
    filter(!is.na(Response.ASHI))
```


```{r}
# Prep for analysis
prep_for_analysis <- function(data) {
  data %>%
    mutate(
      Condition.Test.Pen = 
        "contrasts<-"(factor(Condition.Test.Pen), , cbind("M" = c(-0.5, 0.5))),
      Condition.Test.OriginalLabel = 
        "contrasts<-"(factor(Condition.Test.OriginalLabel), , cbind("SH" = c(-0.5, 0.5))),
      Block = Block - 1) %>%
    select(Experiment, Condition.Test.OriginalLabel, Condition.Test.Pen, Block, Condition.Test.Audio, ParticipantID, Response.ASHI) 
}

my_plots <- function(m) {
  plot(conditional_effects(m, method = "posterior_linpred"), ask = F)
}

my_hypotheses <- function(m, experiment) { 
  format <-  
    . %>%
    rename(BF = Evid.Ratio) %>%
    mutate(
      Experiment = experiment,
      across(
        c("Estimate", "Est.Error", starts_with("CI"), "Post.Prob"),
        ~ signif(.x, 3)),
      BF = ifelse(is.infinite(BF), paste(">", ndraws(m)), as.character(round(BF, 1)))) %>% 
    relocate(Experiment, everything())

  # mo() operators imply that the effects of the other variables are assessed at the reference level of the
  # monotonic predictor. For Block, this is exactly what we want: evaluation of effects in the first Block.
  # However, for the continuum, we'd like to assess effects in the middle of the continuum. This is taken 
  # into account below.
  list(
    bind_rows(
    hypothesis(m, "bsp_moCondition.Test.Audio > 0", class = NULL, scope = "standard")$hypothesis %>% 
      mutate(Hypothesis = "Acoustic continuum more ASHI-like -> more ASHI-responses"),
    # There are 5 continuum steps above the baseline, so we add 2.5 * the interaction of continuum and the 
    # effect of interest to the effect of interest. (a more precise estimate could be obtained by following
    # Figure 1 in BÃ¼rkner & Charpentier, which takes into account the specific simo estimates).
    hypothesis(
      m, 
      "b_Condition.Test.OriginalLabelSH + 2.5 * bsp_moCondition.Test.Audio:Condition.Test.OriginalLabelSH > 0", 
      class = NULL, scope = "standard")$hypothesis %>% 
      mutate(Hypothesis = "Visual label ASHI -> more ASHI-responses"),
    hypothesis(
      m, 
      "b_Condition.Test.PenM  + 2.5 * bsp_moCondition.Test.Audio:Condition.Test.PenM < 0", 
      class = NULL, scope = "standard")$hypothesis %>% 
      mutate(Hypothesis = "Pen location Mouth -> fewer ASHI-responses")) %>% 
      format() %>%
      kable(caption = "Main effects in Block 1"),
  bind_rows(
    hypothesis(m, "bsp_moBlock:moCondition.Test.Audio < 0", class = NULL, scope = "standard")$hypothesis %>% 
      mutate(Hypothesis = "Continuum effect decreases over blocks"),
    hypothesis(m, "bsp_moBlock:Condition.Test.OriginalLabelSH + 2.5 * bsp_moBlock:moCondition.Test.Audio:Condition.Test.OriginalLabelSH < 0", class = NULL, scope = "standard")$hypothesis %>% 
      mutate(Hypothesis = "Visual label effect decreases over blocks"),
    hypothesis(m, "bsp_moBlock:Condition.Test.PenM + 2.5 * bsp_moBlock:moCondition.Test.Audio:Condition.Test.PenM > 0", class = NULL, scope = "standard")$hypothesis %>% 
      mutate(Hypothesis = "Pen effect decreases over blocks")) %>% 
    format()%>%
    kable(caption = "Changes across blocks"),
  bind_rows(
    hypothesis(m, "bsp_moCondition.Test.Audio:Condition.Test.PenM < 0", class = NULL, scope = "standard")$hypothesis %>% 
      mutate(Hypothesis = "Pen effect increases for more ASHI-like acoustic input")) %>% 
    format() %>%
    kable(caption = "Changes across acoustic continuum"))
}
```

```{r}
fit_test_model <- function(data, experiment) {
  m <- brm(
    Response.ASHI ~
      1 + Condition.Test.OriginalLabel * Condition.Test.Pen * mo(Block) * mo(Condition.Test.Audio) +
      (1 + Condition.Test.OriginalLabel * Condition.Test.Pen * mo(Condition.Test.Audio) | ParticipantID),
    data = 
      data %>%
      filter(Experiment %in% experiment) %>% 
      prep_for_analysis(),
    family = "bernoulli",
    prior = priors,
    sample_prior = "yes",
    backend = "cmdstanr",
    chains = 4, 
    cores = min(parallel::detectCores(), 4), 
    threads = threading(threads = 4),
    file = paste("../models/Exp", paste(experiment, collapse = "-"), sep = "-"))
  
  return(m)
}

m.Exp1a <- fit_test_model(d.test, "CISP-1a")
m.Exp1b <- fit_test_model(d.test, "CISP-1b")
m.Exp1c <- fit_test_model(d.test, "CISP-1c")

my_hypotheses(m.Exp1a, experiment = "Exp 1a")
my_hypotheses(m.Exp1b, experiment = "Exp 1b")
my_hypotheses(m.Exp1c, experiment = "Exp 1c")
```

